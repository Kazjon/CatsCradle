"""
* EmotionalModule (manages the marionette's emotional state) [Kaz/Steph]
  - Maintains a geometric structure representing the emotional state
  - Applies reactions generated by the Reactors to that state
  - Updates the state over time (as strong emotions naturally fade)
  - Triggers Actions (as determined by strong emotional states)
  - [Optional] May apply modifiers to parameters of all actions (i.e. sadness makes movements slower)
"""
import numpy as np
from mpl_toolkits.mplot3d import Axes3D
import math
import itertools
import matplotlib
matplotlib.use("QT5Agg")
import matplotlib.pyplot as plt
plt.ion()

#The points in 3d space on the 3-simplex (i.e. form a tetrahedron) and thus represent the four emotions.
simplex_points = np.asarray([[1, 0, 0],
                             [-1. / 3., math.sqrt(8) / 3., 0],
                             [-1. / 3., -math.sqrt(2) / 3., math.sqrt(2. / 3.)],
                             [-1. / 3., -math.sqrt(2) / 3., -math.sqrt(2. / 3.)]                             ])
EMOTION_LABELS = ["fear", "surprise", "longing", "shame"]

EMOTION_DELTAS = {"tiny": 0.001, "small": 0.005, "moderate": 0.05, "large": 1, "extreme": 2, "instant": 5}

def try_add(emotions,k,v):
    try:
        emotions[k] += v
    except:
        emotions[k] = v

def softmax(x):
    '''Compute softmax values for each sets of scores in x.  Used to normalise emotion vectors.'''
    return np.exp(x) / np.sum(np.exp(x), axis=0)

def normalise_emotion_vector(raw_vector):
    '''Normalise 4d emotion vectors into [0..1], summing to 1.'''
    if type(raw_vector[0]) is not list:
        raw_vector = [raw_vector]
    return np.asarray([softmax(p) for p in raw_vector])

def map_to_euclidean(raw_points):
    '''Turns a point in un-normalised emotional space (a length 4 vector) into a point in emotional space.'''
    return np.asarray([np.sum([simplex_points[i] * p[i] for i in range(4)], axis=0) for p in normalise_emotion_vector(raw_points)])

class EmotionModule(object):
    def __init__(self,response_module, drag_coefficient = 0.5, decay_coefficient = 0.975, visualise=False):
        self.response_module = response_module
        self.acceleration = np.zeros(4)
        self.velocity = np.zeros(4)
        self.position = np.zeros(4)
        self.drag = np.asarray([drag_coefficient] * 4)
        self.decay = np.asarray([decay_coefficient] * 4)
        self.max_position_value = 10.
        self.visualise = visualise
        self.frameskip_count = 0
        if visualise:
            self.fig = plt.figure()
            self.ax = self.fig.add_subplot(111, projection='3d')
            xs, ys, zs = simplex_points.T
            self.ax.scatter(xs, ys, zs, c='r', marker="o", s=30)

            for x,y,z,l in zip(xs, ys, zs, EMOTION_LABELS):
                self.ax.text(x, y, z, l)
            xs,ys,zs = np.asarray(list(itertools.chain.from_iterable(itertools.combinations(list(simplex_points),2)))).T
            self.ax.plot(xs,ys,zs,color="red",alpha=0.25,linewidth=1)

            x, y, z = map_to_euclidean(self.position).T
            self.pos_plot = self.ax.scatter(x, y, z, c='b', marker="o", s=100)

            plt.show()

    def update(self,audience, plot_frameskip = 3):
        self.velocity += self.acceleration
        self.position += self.velocity
        self.position = np.minimum([self.max_position_value]*4,self.position)
        self.velocity *= self.drag
        self.position *= self.decay
        self.acceleration = np.zeros(4)
        #print "Raw: ",np.round(self.position,2), "  Mapped: ",np.round(map_to_euclidean(self.position),2)
        self.frameskip_count += 1
        if self.visualise and self.frameskip_count == plot_frameskip:
            self.pos_plot._offsets3d = map_to_euclidean(self.position).T
            self.fig.canvas.draw()
            self.frameskip_count = 0
            #plt.pause(0.01)
        self.response_module.update(self, audience)


    #This is triggered by Reactor objects, part of the SensorModule that trigger in response to particular sensed states.
    def affectEmotions(self,emotional_delta_dict):
        emotional_delta = [emotional_delta_dict[label] if label in emotional_delta_dict.keys() else 0.0 for label in EMOTION_LABELS]
        self.acceleration += np.asarray(emotional_delta)


    def emotion_as_dict(self):
        return {label:emotion[0] for label,emotion in zip(EMOTION_LABELS,normalise_emotion_vector(self.position).T)}
